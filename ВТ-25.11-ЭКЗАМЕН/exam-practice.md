# Практические задачи по дисциплине "Основы алгоритмизации и программирования" (C#)

---

## Билет 1. Практические задачи

### Задача 1: Анализатор типов данных

Разработайте программу, которая принимает произвольный объект и выводит полную информацию о его типе: размер в памяти (для value types), находится ли в стеке или куче, выполняется ли boxing при присваивании в object, все поля и их типы. Программа должна корректно обрабатывать nullable типы, generics и сложные вложенные структуры.

### Задача 2: Оптимизатор boxing/unboxing

Дан код программы с множественными операциями boxing/unboxing (например, ArrayList с int значениями). Перепишите код, устранив все boxing/unboxing операции с использованием generic-коллекций. Замерьте и сравните производительность до и после оптимизации для 1 000 000 операций. Объясните результаты.

### Задача 3: Система конвертации типов

Реализуйте систему безопасного преобразования между типами данных, которая учитывает переполнение, потерю точности и некорректные преобразования. Система должна работать с checked/unchecked контекстами, обрабатывать явные и неявные преобразования, и логировать все потенциально опасные операции.

---

## Билет 2. Практические задачи

### Задача 1: Интерпретатор логических выражений

Создайте интерпретатор, который принимает строку с логическим выражением (с операторами &&, ||, !, ==, !=, <, >, <=, >=) и переменными, и вычисляет результат. Реализуйте короткое замыкание (short-circuit evaluation). Поддержите приоритет операторов и скобки. Входные данные: выражение и словарь переменных со значениями.

### Задача 2: Умный switch для маршрутизации

Разработайте систему маршрутизации HTTP-запросов с использованием современного switch expression и pattern matching. Система должна учитывать метод запроса (GET/POST/PUT/DELETE), путь (с возможностью параметров), заголовки и тело запроса. Реализуйте не менее 20 различных маршрутов с разными паттернами.

### Задача 3: Безопасная навигация по объектам

Создайте класс для работы с глубоко вложенными JSON-подобными структурами. Используйте null-conditional и null-coalescing операторы для безопасного доступа к данным любой глубины вложенности. Реализуйте методы: GetValue<T>(path), SetValue(path, value), DeleteValue(path), где path - строка типа 'user.address.city.name'.

---

# ... (в этом файле будут аналогично расписаны задачи для всех 30 билетов)

## Требования к выполнению практических задач

1. **Качество кода:**
   - Код должен быть читаемым и хорошо структурированным
   - Используйте осмысленные имена переменных и методов
   - Добавляйте комментарии к сложным участкам кода
   - Следуйте соглашениям о стиле кодирования C#

2. **Функциональность:**
   - Программа должна корректно работать на всех тестовых случаях
   - Обработайте граничные случаи и потенциальные ошибки
   - Добавьте валидацию входных данных

3. **Производительность:**
   - Учитывайте временную и пространственную сложность алгоритмов
   - Оптимизируйте код где это необходимо
   - Избегайте лишних операций и выделения памяти

4. **Тестирование:**
   - Создайте тестовые данные для проверки работы программы
   - Протестируйте программу на различных входных данных
   - Убедитесь в корректности результатов

5. **Документация:**
   - Добавьте XML-комментарии к публичным методам
   - Опишите алгоритм решения задачи
   - Укажите временную и пространственную сложность

## Критерии оценки практических задач

**Задача 1 (базовый уровень):**
- 10 баллов - полностью работающее решение с оптимизацией
- 7 баллов - работающее решение без оптимизации
- 4 балла - частично работающее решение
- 0 баллов - нерабочее решение

**Задача 2 (средний уровень):**
- 15 баллов - полностью работающее решение с оптимизацией и тестами
- 10 баллов - работающее решение без оптимизации
- 5 баллов - частично работающее решение
- 0 баллов - нерабочее решение

**Задача 3 (продвинутый уровень):**
- 25 баллов - полностью работающее решение с оптимизацией, тестами и документацией
- 18 баллов - работающее решение с частичной оптимизацией
- 10 баллов - работающее решение без оптимизации
- 0 баллов - нерабочее решение

**Общая оценка практической части:**
- 45-50 баллов: Отлично (5)
- 35-44 балла: Хорошо (4)
- 25-34 балла: Удовлетворительно (3)
- Менее 25 баллов: Неудовлетворительно (2)

## Рекомендации по подготовке

1. **Изучите теорию:**
   - Повторите материалы по всем темам курса
   - Разберите примеры кода из репозитория
   - Понимайте принципы работы алгоритмов и структур данных

2. **Практикуйтесь:**
   - Решайте задачи на платформах LeetCode, HackerRank
   - Реализуйте базовые алгоритмы самостоятельно
   - Анализируйте чужой код

3. **Готовьтесь к экзамену:**
   - Просмотрите все теоретические вопросы
   - Попробуйте решить несколько практических задач по времени
   - Повторите синтаксис C# и основные конструкции языка

4. **На экзамене:**
   - Внимательно читайте условия задач
   - Начинайте с простых задач
   - Планируйте время на каждую задачу
   - Тестируйте код перед сдачей

## Примеры оформления решений

### Пример 1: Простая задача

```csharp
/// <summary>
/// Вычисляет факториал числа рекурсивно
/// Временная сложность: O(n)
/// Пространственная сложность: O(n) из-за рекурсии
/// </summary>
/// <param name="n">Неотрицательное целое число</param>
/// <returns>Факториал числа n</returns>
/// <exception cref="ArgumentException">Если n отрицательное</exception>
public static long Factorial(int n)
{
    if (n < 0)
        throw new ArgumentException("Число должно быть неотрицательным", nameof(n));
    
    if (n == 0 || n == 1)
        return 1;
    
    return n * Factorial(n - 1);
}
```

### Пример 2: Сложная задача с тестами

```csharp
/// <summary>
/// Реализация бинарного поиска в отсортированном массиве
/// Временная сложность: O(log n)
/// Пространственная сложность: O(1)
/// </summary>
public class BinarySearch
{
    public static int Search(int[] array, int target)
    {
        if (array == null)
            throw new ArgumentNullException(nameof(array));
        
        int left = 0;
        int right = array.Length - 1;
        
        while (left <= right)
        {
            int mid = left + (right - left) / 2;
            
            if (array[mid] == target)
                return mid;
            
            if (array[mid] < target)
                left = mid + 1;
            else
                right = mid - 1;
        }
        
        return -1; // Элемент не найден
    }
    
    // Тесты
    public static void RunTests()
    {
        // Тест 1: элемент найден
        int[] arr1 = { 1, 3, 5, 7, 9 };
        Debug.Assert(Search(arr1, 5) == 2);
        
        // Тест 2: элемент не найден
        Debug.Assert(Search(arr1, 4) == -1);
        
        // Тест 3: первый элемент
        Debug.Assert(Search(arr1, 1) == 0);
        
        // Тест 4: последний элемент
        Debug.Assert(Search(arr1, 9) == 4);
        
        Console.WriteLine("Все тесты пройдены успешно!");
    }
}
```

## Часто задаваемые вопросы

**Q: Можно ли использовать встроенные методы .NET?**
A: Да, но в задачах, где требуется реализовать конкретный алгоритм, нужно реализовать его самостоятельно.

**Q: Нужно ли обрабатывать исключения?**
A: Да, код должен корректно обрабатывать ошибки и исключительные ситуации.

**Q: Можно ли использовать интернет на экзамене?**
A: Уточните у преподавателя. Обычно разрешается использовать документацию .NET.

**Q: Сколько времени дается на практическую часть?**
A: Обычно 90-120 минут в зависимости от сложности задач.

**Q: Что делать, если не получается решить задачу?**
A: Напишите алгоритм решения словами, частичное решение тоже оценивается.

---

**Удачи на экзамене!**
