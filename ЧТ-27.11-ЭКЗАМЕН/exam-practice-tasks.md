# ПРАКТИЧЕСКИЕ ЗАДАЧИ

## БИЛЕТ 1

### Задача 1: Анализатор типов данных
Напишите программу, которая анализирует произвольный объект через рефлексию и выводит:
- Категория типа (Value/Reference Type)
- Размер в байтах (для value types)
- Месторасположение (Stack/Heap)
- Выполняется ли boxing
- Все публичные и приватные поля с их типами
Тестируйте на int, string, List<int>, ValueTuple, nullable типах.

### Задача 2: Оптимизатор boxing/unboxing
Создайте две версии кода для 1 000 000 операций:
- Неоптимизированная: ArrayList с int значениями (boxing/unboxing)
- Оптимизированная: List<int> (без boxing)
Измерьте: время выполнения, потребление памяти, количество сборок мусора.
Постройте таблицу сравнения с ускорением в разах.

### Задача 3: Система конвертации типов
Реализуйте SafeConverter<T> с методом Convert<TFrom, TTo>(value).
Обработайте случаи: переполнение, потеря точности, некорректный формат.
Возвращайте ConversionResult с полями: Status, Value, ErrorMessage, Warnings.
Логируйте все опасные операции. Протестируйте на 10+ типах данных.

---

## БИЛЕТ 2

### Задача 1: Интерпретатор логических выражений
Напишите парсер и вычислитель выражений: "x > 5 && (y < 10 || z >= 15)"
Поддерживайте: операторы (&&, ||, !, ==, !=, <, >, <=, >=), скобки, переменные.
Реализуйте короткое замыкание (short-circuit evaluation).
Выведите AST (Abstract Syntax Tree) структуру выражения.
Тестируйте на 20+ выражениях разной сложности.

### Задача 2: Умный switch для маршрутизации
Создайте SmartRouter с использованием switch expressions и pattern matching.
Поддержите 25+ маршрутов: GET /users, POST /users, GET /users/{id}, DELETE /posts/{id}/comments/{cid}
Обрабатывайте параметры пути, методы запроса, заголовки Content-Type, Authorization.
Логируйте все совпадения маршрутов. Верните struct RouteMatch с параметрами.

### Задача 3: Безопасная навигация по объектам
Реализуйте SafeNavigator с методами:
- GetValue<T>(obj, "user.address.city") -> T или default
- SetValue(obj, "user.phone.mobile", "+1234567890") -> создает промежуточные объекты
- DeleteValue(obj, "user.address.zip")
- PathExists(obj, "user.address.country")
Обработайте вложенность любой глубины, массивы (path[0].name), условия ([?age>26].name).

---

## БИЛЕТ 3

### Задача 1: Генератор последовательностей с yield
Напишите 4 итератора с yield return:
1. FibonacciSequence(int count) - первые N чисел Фибоначчи
2. PrimeNumbers(int from, int to) - простые числа в диапазоне
3. Permutations<T>(T[] array) - все перестановки массива
4. Combinations<T>(T[] array, int k) - все комбинации из N по K

Все должны использовать отложенное вычисление (не вычислять всё сразу).
Протестируйте на больших значениях (N=1000000 для Фибоначчи, k=15 для комбинаций).

### Задача 2: Параллельная обработка с оптимизацией
Для массива 10^7 случайных чисел посчитайте сумму квадратов четных чисел тремя способами:
1. Обычный foreach (последовательно)
2. Parallel.ForEach с разными DegreeOfParallelism (1, 2, 4, 8, 16)
3. PLINQ с AsParallel()
Измерьте время каждого варианта. Постройте график зависимости времени от параллелизма.
Вычислите speedup относительно последовательного варианта.

### Задача 3: Обработчик вложенных циклов
Найдите все пифагоровы тройки (a² + b² = c²) для N=1000 тремя способами:
1. Brute Force: три вложенных цикла (O(n³))
2. Оптимизированно: два цикла + вычисление третьего (O(n²))
3. Формулы Евклида для примитивных троек (O(n))
Для каждого способа измерьте время. Покажите ускорение. Выведите первые 15 троек.

---

## БИЛЕТ 4

### Задача 1: Матричный калькулятор
Создайте класс Matrix<T> для матриц произвольного размера с операциями:
- Сложение (+), вычитание (-), умножение (*)
- Транспонирование, определитель, обратная матрица
- Операторы: ==, !=, [], индексация
- Методы: Rank(), IsSymmetric(), Trace()
Реализуйте для double и decimal. Проверяйте размеры перед операциями.
Протестируйте на матрицах 2×2, 3×3, 10×10, 100×100.

### Задача 2: Работа с Span<T> для производительности
Для массива 10^8 int'ов реализуйте три версии:
1. Обычные методы с int[] (Reverse, Rotate, FindMedian)
2. С использованием Span<T> (ReverseSpan, RotateSpan, FindMedianSpan)
3. С stackalloc для маленьких буферов
Измерьте время и потребление памяти для каждой версии.
Сравните performance и объем памяти. Покажите выигрыш Span<T>.

### Задача 3: Динамический многомерный массив
Реализуйте DynamicArray<T> с поддержкой произвольной размерности (1D, 2D, 3D, ..., ND):
- GetValue(params int[] indices)
- SetValue(T value, params int[] indices)
- Resize(int[] newShape)
- Slice(int[] start, int[] end)
- Итератор для перебора элементов
Поддержите сериализацию. Тестируйте на 2D, 3D, 4D массивах с изменением размера.

---

## БИЛЕТ 5

### Задача 1: Построитель цепочек вызовов (Fluent API)
Создайте SqlQueryBuilder для построения SQL запросов методами:
- Select(params string[] columns)
- From(string table)
- Where(string condition, params object[] parameters)
- Join(string table, string condition)
- OrderBy(string column, SortOrder order)
- GroupBy(params string[] columns)
- Having(string condition)
- Limit(int count)
- Build() -> string (генерирует SQL)

Все методы возвращают this для цепочки. Тестируйте на 10+ комплексных запросах.

### Задача 2: Система middleware с делегатами
Создайте RequestPipeline для цепочки обработчиков (Chain of Responsibility):
- Класс с методом Use(Func<Request, Response, Task<Response>> middleware)
- Реализуйте 5 middleware: LoggingMiddleware, AuthenticationMiddleware, CachingMiddleware, ErrorHandlingMiddleware, CompressionMiddleware
- Каждый может перехватить, изменить, или прервать цепочку
- Execute(request) выполняет всю цепь
Протестируйте все middleware в разном порядке.

### Задача 3: Расширения для коллекций
Создайте extension methods для IEnumerable<T>:
- Chunk(int size) - разбить на чанки
- Window(int size) - скользящее окно
- DistinctBy<TKey>(Func<T, TKey> selector) - уникальные по ключу
- MinBy<TKey>(Func<T, TKey> selector), MaxBy (минимум/максимум по ключу)
- Batch(int size) - группировка пакетами
- Shuffle() - перемешать элементы
- Cycle(int count) - повторить последовательность N раз

Все должны использовать yield return. Напишите unit-тесты для каждого.

---

## БИЛЕТ 6

### Задача 1: Обход дерева с мемоизацией
Создайте BinarySearchTree<T> с методами:
- Insert(T value), Delete(T value), Find(T value)
- InOrder(), PreOrder(), PostOrder() - обходы с выводом элементов
- Height - высота дерева с мемоизацией
- IsBalanced() - проверка сбалансированности
- Size - размер дерева с кешированием

Добавьте 10000 случайных элементов. Измерьте время вычисления высоты с мемоизацией и без.
Покажите разницу в производительности.

### Задача 2: Решатель задачи о N ферзях
Напишите решатель NQueensSolver для N=8:
- Найти все 92 решения методом backtracking
- Оптимизируйте битовыми операциями для быстроты
- Каждое решение представьте как массив [column0, column1, ..., column7]
- Выведите все решения в консоль
- Измерьте время решения
- Визуализируйте первые 3 решения как шахматные доски

### Задача 3: Преобразование рекурсии в итерацию
Возьмите два рекурсивных алгоритма и переделайте в итеративные:
1. QuickSort - рекурсивный и итеративный через Stack<(start, end)>
2. Вычисление чисел Каталана - рекурсивный и итеративный через табуляцию

Для каждой пары измерьте: время, потребление памяти, максимальную глубину стека.
Сравните на входных данных: n=10000, n=100000.

---

## БИЛЕТ 7

### Задача 1: Сравнительный анализ алгоритмов сортировки
Реализуйте 7 алгоритмов сортировки:
- BubbleSort, SelectionSort, InsertionSort, MergeSort, QuickSort, HeapSort, CountingSort

Протестируйте каждый на 4 типах массивов размером 100000 элементов:
1. Случайный порядок
2. Отсортированный (лучший случай)
3. Обратно отсортированный (худший случай)
4. С повторениями (много одинаковых элементов)

Для каждого: измерьте время, подсчитайте количество сравнений и обменов.
Постройте графики сравнения. Покажите O-сложность каждого.

### Задача 2: Гибридная сортировка (IntroSort)
Реализуйте IntroSort - алгоритм как в Array.Sort():
- Начинаем с QuickSort
- При превышении глубины рекурсии 2*log(n) переключаемся на HeapSort
- Для подмассивов < 16 элементов используем InsertionSort

Протестируйте на массивах 100000, 1000000 элементов.
Сравните с встроенным Array.Sort() - время должно быть близко.
Измерьте переключения между алгоритмами.

### Задача 3: Внешняя сортировка файлов
Создайте файл с 10 млн чисел (размер > 500 МБ).
Отсортируйте его внешней сортировкой при ограничении памяти 100 МБ:
- Разбейте файл на блоки, поместившиеся в памяти
- Отсортируйте каждый блок (QuickSort)
- Слейте блоки K-way merge (многопутевое слияние)

Измерьте: количество операций чтения/записи, время сортировки, пиковое потребление памяти.
Проверьте корректность результата.

---

## БИЛЕТ 8

### Задача 1: Система поиска подстрок
Реализуйте 3 алгоритма поиска подстроки в строке:
1. Наивный алгоритм (проверка на каждой позиции)
2. Бойера-Мура (пропуск в зависимости от символа)
3. Кнута-Морриса-Пратта (префикс-функция)

Для каждого подсчитайте количество сравнений символов.
Протестируйте на текстах: 1KB, 100KB, 1MB, 10MB.
Паттерны: короткие (3-5 символов), средние (20-50), длинные (100-500).
Постройте таблицу сравнения алгоритмов.

### Задача 2: Поиск k-го наименьшего элемента
Реализуйте 3 варианта:
1. Простой: Sort + индекс (худший случай)
2. QuickSelect (среднее O(n), худшее O(n²))
3. Медиана медиан (гарантированное O(n))

Для каждого найдите k-й элемент в массиве 10^6 элементов, k от 10 до 999990.
Измерьте время всех трех вариантов.
Покажите, когда какой вариант эффективнее.

### Задача 3: Многомерный поиск в дереве (K-D дерево)
Реализуйте K-D дерево для 2D и 3D точек:
- Insert(point) - вставка точки
- Delete(point) - удаление
- FindNearest(point) - ближайший сосед
- FindInRange(min, max) - все точки в прямоугольной области
- Size, Height - статистика

Создайте 10000 случайных 2D и 3D точек. Протестируйте все операции.
Сравните скорость поиска ближайшего соседа: K-D дерево vs линейный поиск.

---

## БИЛЕТ 9

### Задача 1: Система управления банковскими счетами
Создайте иерархию классов:
- Account (базовый)
- SavingsAccount (с начислением процентов)
- CheckingAccount (бесплатные переводы)
- CreditAccount (кредитная линия)

Методы: Deposit, Withdraw, Transfer, CalculateInterest, GetStatement.
Каждый тип счета имеет свои комиссии и ограничения.
Ведите историю всех транзакций. Протестируйте все операции и валидацию.

### Задача 2: Фабрика объектов с рефлексией
Создайте ObjectFactory<T> для создания экземпляров по имени типа:
- CreateInstance(string typeName, params object[] args) - создание через конструктор
- CreateAndInitialize(string typeName, Dictionary<string, object> properties) - инициализация свойств
- RegisterSingleton(string name, object instance) - регистрация синглтона
- CreateFromAssembly(Assembly assembly, string typeName) - из другой сборки

Используйте кеширование метаданных типов. Обработайте ошибки.
Протестируйте создание 10+ типов с разными конструкторами.

### Задача 3: Система клонирования объектов
Реализуйте DeepCloner с методом Clone<T>(T obj):
- Поверхностное клонирование (MemberwiseClone)
- Глубокое клонирование (рекурсивное копирование всех полей)
- Обработка циклических ссылок (с помощью Dictionary<object, object>)
- Поддержка массивов, List<T>, Dictionary<K,V>
- Копирование приватных полей через рефлексию

Тестируйте на объектах с разной глубиной вложенности, циклическими ссылками.
Сравните производительность: рефлексия vs сериализация vs Expression Trees.

---

## БИЛЕТ 10

### Задача 1: Умные свойства с валидацией
Создайте класс ValidatableObject с автоматической валидацией:
- Атрибуты: [Required], [Range(min, max)], [StringLength(min, max)], [Email], [Phone], [RegexPattern(pattern)]
- При установке свойства автоматически проверяется валидация
- Сохраняются все ошибки в коллекции ValidationErrors
- Событие PropertyChanged при каждом изменении
- Метод IsValid() возвращает bool

Создайте класс User с 10+ свойствами. Протестируйте валидацию.

### Задача 2: Fluent Builder для конфигурации
Создайте ConfigurationBuilder с вложенными builders:
- DatabaseConfigBuilder: Host, Port, Database, Username, Password
- LoggingConfigBuilder: Level, FilePath, MaxFileSize, MaxFiles
- CacheConfigBuilder: Enabled, Duration, MaxItems
- EmailConfigBuilder: SmtpHost, Port, From, Password

Все параметры строго типизированы. Build() возвращает immutable Configuration.
Валидация при Build(). Вывести конфиг в JSON и обратно.

### Задача 3: Прокси-класс для логирования (AOP)
Создайте LoggingProxy<T> с использованием DispatchProxy или RealProxy:
- Логирование входа/выхода методов с параметрами и результатом
- Измерение времени выполнения каждого метода
- Кеширование результатов методов без параметров
- Обработка и логирование исключений
- Счетчики: сколько раз вызван каждый метод

Применить к интерфейсу с 5+ методами. Вывести статистику всех вызовов.

---

## БИЛЕТ 11

### Задача 1: Иерархия геометрических фигур
Создайте иерархию классов Shape:
- 2D: Circle (радиус), Rectangle (ширина, высота), Triangle (три стороны)
- 3D: Sphere (радиус), Cube (сторона), Cylinder (радиус, высота)

Методы: Area(), Perimeter() (для 2D), Volume() (для 3D), ToString().
Операторы сравнения: ==, != (по площади/объему).
Sealed для некоторых классов. Полиморфная коллекция фигур.
Посчитайте общую площадь и объем коллекции.

### Задача 2: Система плагинов
Создайте архитектуру плагинов:
- Базовый класс Plugin с методами Initialize(), Execute(), Dispose()
- PluginManager: LoadPluginsFromDirectory(), Execute(), GetPluginStats()
- Изоляция через AppDomain (или AssemblyLoadContext в .NET Core)
- Создайте 5 примеров плагинов (MathPlugin, StringPlugin, DataPlugin, etc.)

Тестируйте загрузку и выгрузку плагинов. Обработайте ошибки при загрузке.

### Задача 3: Цепочка наследования с паттернами
Реализуйте Template Method для обработки заказов:
- Базовый класс OrderProcessor с шаблоном:
  1. Validate() - проверка
  2. CalculatePrice() - расчет цены
  3. ApplyDiscount() - применить скидку
  4. ProcessPayment() - обработка платежа
  5. GenerateInvoice() - генерация счета

Создайте подклассы: StandardOrder, ExpressOrder, SubscriptionOrder, WholesaleOrder.
Каждый переопределяет нужные методы. Обработайте 100 заказов разных типов.

---

## БИЛЕТ 12

### Задача 1: Полиморфная коллекция документов
Создайте систему документов:
- Document - базовый абстрактный класс
- TextDocument, SpreadsheetDocument, PresentationDocument, PDFDocument

Методы: Open(), Save(), Export(format), Print(), Search(text), GetMetadata().
DocumentManager для управления коллекцией разнородных документов.
Реализуйте все методы полиморфно. Создайте 20+ документов, выполните операции.

### Задача 2: Система отчетов с разными форматами
Создайте интерфейс IReportGenerator и реализации:
- PDFReportGenerator
- ExcelReportGenerator
- HTMLReportGenerator
- JSONReportGenerator

ReportFactory возвращает нужный генератор по типу.
Один источник данных (List<Employee>) преобразуется в разные форматы.
Каждый генератор должен быть полностью независим. Тестируйте все форматы.

### Задача 3: Динамический диспетчер методов
Реализуйте Multiple Dispatch для игры "Камень-Ножницы-Бумага-Ящерица-Спок":
- 5 классов: Choice (базовый), Rock, Paper, Scissors, Lizard, Spock
- Метод Battle(Choice other) определяет победителя (полиморфно)
- Используйте Visitor паттерн или таблицу стратегий
- 20 возможных комбинаций, для каждой определен исход

Симулируйте 1000 боев между случайными выборами. Подсчитайте статистику.

---

## БИЛЕТ 13

### Задача 1: Абстрактная фабрика для GUI
Реализуйте Abstract Factory для кроссплатформенного UI:
- Интерфейс GUIFactory с методами CreateButton(), CreateTextBox(), CreateCheckBox()
- Конкретные фабрики: WindowsFactory, MacOSFactory, LinuxFactory
- Каждый компонент имеет Render() метод
- IButton, ITextBox, ICheckBox интерфейсы

Создайте приложение, которое работает с любой фабрикой без изменения кода.
Выведите какие компоненты созданы для каждой платформы.

### Задача 2: Система обработки платежей
Создайте систему платежей:
- Абстрактный класс PaymentProcessor с методами:
  ValidatePaymentInfo(), ProcessTransaction(), GenerateReceipt(), HandleError()
- Конкретные процессоры: CreditCardProcessor, PayPalProcessor, CryptoProcessor, BankTransferProcessor
- Каждый имеет свою логику валидации и обработки
- Используйте Template Method для общего workflow

Обработайте 50 платежей разными способами. Выведите итоги.

### Задача 3: Простой IoC контейнер
Реализуйте IoC контейнер:
- IServiceProvider - интерфейс для получения сервисов
- Register<TInterface, TImplementation>() - регистрация
- Resolve<T>() - получение экземпляра
- Жизненные циклы: Singleton, Transient, Scoped
- Автоматическое внедрение зависимостей через конструктор
- Обнаружение циклических зависимостей

Создайте 10+ классов с зависимостями и протестируйте контейнер.

---

## БИЛЕТ 14

### Задача 1: Множественная реализация интерфейсов
Создайте класс SmartDevice, реализующий интерфейсы:
- IConnectable: Connect(), Disconnect()
- IConfigurable: LoadConfig(), SaveConfig()
- IMonitorable: GetStatus(), GetMetrics()
- IControllable: Start(), Stop(), Restart()

Некоторые методы конфликтуют по именам - используйте explicit implementation.
Добавьте события для изменения состояния. Протестируйте все интерфейсы.

### Задача 2: Компаратор с множественными критериями
Создайте класс Employee (Name, Age, Salary, Department, HireDate):
- Реализуйте IComparable<Employee> для сортировки по Salary
- Создайте несколько IComparer<Employee> для других критериев
- CompositeComparer который комбинирует несколько компараторов
- Сортировка: сначала по Department, затем по Salary

Создайте 100 сотрудников и отсортируйте разными способами. Выведите результаты.

### Задача 3: Универсальный репозиторий
Реализуйте generic-интерфейс IRepository<T>:
- GetById(id), GetAll(), Add(item), Update(item), Delete(id)
- Find(predicate) - поиск по условию
- Абстрактный класс BaseRepository<T>
- Конкретные реализации: InMemoryRepository<T>, FileRepository<T>

Используйте Unit of Work паттерн. Протестируйте все операции.

---

## БИЛЕТ 15

### Задача 1: Generic-дерево с ограничениями
Реализуйте TreeNode<T> где T : IComparable<T>:
- Insert, Delete, Find, GetHeight, IsBalanced()
- Extension методы: FindMin<T>(), FindMax<T>(), Traverse()
- Балансировка (AVL или Red-Black дерево)
- Сериализация/десериализация дерева

Вставьте 10000 элементов. Измерьте высоту, проверьте баланс.

### Задача 2: Кеш с истечением времени
Создайте ExpiringCache<TKey, TValue>:
- Add(key, value, expiration) - добавить с TTL
- Get(key) - получить или null если истекло
- Remove(key), Clear()
- Фоновый поток для очистки истекших
- Статистика: HitRate, MissRate, Evictions

Сделайте потокобезопасным. Тестируйте на 10000 элементах, различных TTL.

### Задача 3: Ковариантность и контравариантность
Создайте иерархию: Animal -> Dog -> Puppy, Cat -> Kitten
Интерфейсы:
- IProducer<out T> с GetValue()
- IConsumer<in T> с SetValue(T)
- IProcessor<T> с обоими методами

Демонстрируйте: IProducer<Dog> = IProducer<Animal> (ковариантность).
IConsumer<Animal> = IConsumer<Dog> (контравариантность).
IProcessor не может быть вариантным. Объясните почему.

---

## БИЛЕТ 16

### Задача 1: Система событий с приоритетами
Создайте EventBus:
- Subscribe<T>(handler, priority) - подписка на событие
- Unsubscribe<T>(handler)
- Publish<T>(eventData) - публикация
- Обработчики с высоким приоритетом выполняются первыми
- Возможность отмены дальнейшей обработки
- Поддержка асинхронных обработчиков

Создайте 5 типов событий, 20+ обработчиков. Симулируйте 100 событий.

### Задача 2: Построитель цепочки обязанностей
Реализуйте RequestPipeline с делегатами Func<Request, Response>:
- Use(handler) - добавить обработчик в цепочку
- Execute(request) - выполнить всю цепь
- 7 обработчиков: валидация, логирование, кеширование, аутентификация, авторизация, rate limiting, обработка

Каждый может прервать цепь или передать дальше. Тестируйте разные порядки.

### Задача 3: Реактивные свойства с событиями
Создайте Observable<T>:
- Subscribe(Action<T> onNext) - подписка
- Select(Func<T, R>) - трансформация (LINQ)
- Where(Func<T, bool>) - фильтрация
- Throttle(TimeSpan) - дроссель событий
- Distinct() - только уникальные значения

ObservableProperty<T> как свойство класса с INotifyPropertyChanged.
Протестируйте на 50+ изменений с различными операторами.

---

## БИЛЕТ 17

### Задача 1: Парсер математических выражений
Создайте парсер для "(x + 5) * (y - 2) / z":
- Постройте Expression Tree
- Скомпилируйте в delegate через Expression.Compile()
- Поддерживайте: +, -, *, /, ^, sin(), cos(), sqrt(), abs()
- Оптимизация для константных выражений

Протестируйте на 50 различных выражениях с переменными.

### Задача 2: LINQ-провайдер для SQL
Разработайте упрощенный LINQ-провайдер:
- Класс Queryable<T> который строит Expression Tree
- ToList() генерирует SQL и выполняет запрос
- Операции: Where, Select, OrderBy, GroupBy, Join
Пример: db.Users.Where(u => u.Age > 18).Select(u => new { u.Name }).ToList()

Протестируйте на 10+ запросах.

### Задача 3: Мемоизация через лямбды
Создайте Memoize<T, R>(Func<T, R> func) для кеширования результатов:
- Версии для Func<T1, R>, Func<T1, T2, R>, Func<T1, T2, T3, R>
- Версия с ограничением размера кеша (LRU eviction)
- Потокобезопасная версия

Протестируйте на вычислении чисел Фибоначчи. Сравните производительность с/без мемоизации.

---

## БИЛЕТ 18

### Задача 1: Анализатор данных с LINQ
Дан CSV файл с продажами (дата, продукт, категория, кол-во, цена, регион):
Реализуйте запросы:
1. Топ-10 продуктов по выручке
2. Продажи по месяцам
3. Средний чек по категориям
4. Рост продаж год-к-году
5. ABC-анализ (распределение Парето)
6. Сезонность (пики продаж)
7. Корреляции между категориями

Используйте query и method syntax. Оптимизируйте запросы.

### Задача 2: Параллельный PLINQ
На 10^7 записей используйте PLINQ:
- Фильтрация, преобразование, группировка, агрегация
- AsParallel(), WithDegreeOfParallelism(), WithExecutionMode()
- Сравните производительность: обычный LINQ, PLINQ, ручной Parallel.ForEach()
Измерьте влияние DegreeOfParallelism. Постройте график.

### Задача 3: Custom LINQ операторы
Напишите extension methods для IEnumerable<T>:
- Median() - медиана
- Mode() - мода
- StandardDeviation() - среднее отклонение
- Percentile(p) - процентиль
- RunningTotal() - накопительная сумма
- ExponentialMovingAverage(alpha) - экспоненциальное среднее
- RollingWindow(size, aggregator) - скользящее окно
- DistinctBy(keySelector, comparer) - уникальные

Протестируйте на статистических данных.

---

## БИЛЕТ 19

### Задача 1: Resilient HTTP клиент
Создайте HttpClient с обработкой ошибок:
- Автоматические повторы с exponential backoff
- Circuit Breaker (после N неудач - open state)
- Timeout для запросов
- Fallback значения
- Пользовательские исключения: TimeoutException, ServiceUnavailableException, RateLimitException
- Логирование всех попыток

Протестируйте на 50+ запросах с моделированием ошибок.

### Задача 2: Валидатор с каскадными правилами
Создайте Validator<T>:
- Цепочка правил валидации
- Простые проверки (StringLength, Range, Email)
- Вложенные объекты и коллекции
- Условные правила (validate X only if Y is true)
- Асинхронные правила (проверка в БД)

Соберите все ошибки за один проход. Протестируйте на сложном объекте.

### Задача 3: Транзакционный обработчик
Реализуйте TransactionScope:
- BeginTransaction(), Commit(), Rollback()
- При исключении - автоматический rollback
- Вложенные транзакции (savepoints)
- Для файлов и коллекций в памяти
- Используйте IDisposable для auto-rollback

Протестируйте на 20+ операциях с ошибками.

---

## БИЛЕТ 20

### Задача 1: Файловый менеджер с метаданными
Создайте FileManager:
- Copy/Move с progress bar
- Двусторонняя синхронизация папок
- Поиск файлов по маске с рекурсией
- Вычисление хеш-сумм (MD5, SHA256)
- Поиск дубликатов
- Сжатие/распаковка ZIP

Используйте асинхронные операции. Обработайте ошибки доступа.

### Задача 2: Логгер с ротацией файлов
Реализуйте логирование в файлы с ротацией:
- Уровни: Trace, Debug, Info, Warning, Error, Fatal
- Ротация по: размеру (max 10MB), времени (ежедневно), количеству (max 30)
- Формат: [timestamp] [level] [thread] [logger] message
- Буферизация записей
- Фильтры по уровню и категориям
- Потокобезопасность

Логируйте 1000000 сообщений, проверьте ротацию.

### Задача 3: Потоковый парсер больших файлов
Парсер CSV/JSON для файлов несколько GB:
- StreamReader для построчного чтения
- Yield return для streaming
- Фильтрация записей на лету
- Агрегация с минимальной памятью
- Parallel processing через Partitioner
- Сравните memory: streaming vs загрузка всего файла

Обработайте файл 2GB.

---

## БИЛЕТ 21

### Задача 1: Универсальный сериализатор
Создайте Serializer<T> поддерживающий:
- JSON, XML, Binary, MessagePack форматы
- Strategy pattern для выбора формата
- Циклические ссылки (с идентификаторами объектов)
- Приватные поля
- Generic типы и коллекции
- Атрибуты: [SerializeMember], [IgnoreMember], [SerializeAs(name)]

Протестируйте на 10+ типов данных.

### Задача 2: Version-tolerant десериализация
Система десериализации устойчивая к изменениям схемы:
- Добавление новых полей (default значения)
- Удаление полей (игнорирование)
- Переименование (через атрибуты)
- Версионирование схемы

При десериализации старых данных в новый класс - корректно.
Протестируйте на 5 версиях структуры данных.

### Задача 3: Компрессия сериализованных данных
SerializationPipeline с трансформациями:
Сериализация -> Компрессия (GZip/Deflate) -> Шифрование (AES) -> Файл.
Каждый шаг stream-based. Decorator pattern.
Измерьте коэффициент сжатия и влияние на производительность.

---

## БИЛЕТ 22

### Задача 1: Пул рабочих потоков
Реализуйте собственный ThreadPool:
- BlockingCollection<Action> для очереди
- Рабочие потоки берут задачи и выполняют
- Регулировка размера пула
- Приоритет задач
- Таймаут выполнения
- Graceful shutdown
- Статистика: задач выполнено, очередь, utilization

Сравните с ThreadPool.QueueUserWorkItem(). Протестируйте на 100000 задач.

### Задача 2: Параллельный обработчик изображений
Программа массовой обработки 1000+ изображений:
- Операции: resize, rotate, convert format, apply filters
- 3 подхода: последовательная, Thread, ThreadPool, Task, Parallel.ForEach, PLINQ
- Сравните время всех подходов
- Обработайте поврежденные файлы
- Progress reporting и отмена
Измерьте ускорение каждого подхода.

### Задача 3: Producer-Consumer с приоритетами
5 производителей генерируют задачи с приоритетами (High, Normal, Low).
3 потребителя обрабатывают приоритетные задачи первыми.
- BlockingCollection или ConcurrentQueue
- Back-pressure (producer паузится при переполнении)
- Визуализация в консоли: количество в очередях, загрузка потребителей

Обработайте 10000 задач.

---

## БИЛЕТ 23

### Задача 1: Dining Philosophers Problem
Классическая задача об обедающих философах:
- 5 философов, 5 вилок, круглый стол
- Для еды нужны 2 вилки (соседние)
- Избегайте deadlock, starvation, livelock
- Три стратегии решения:
  1. Иерархия ресурсов
  2. Официант (дополнительный поток)
  3. Асимметричное (четные/нечетные)

Визуализируйте состояние (кто ест, думает, ждет).

### Задача 2: Lock-free структура данных
Реализуйте lock-free очередь вручную Interlocked операциями:
- Enqueue(item), TryDequeue(out item)
- Linked list с atomic операциями head/tail
- Сравните с обычной очередью под lock и ConcurrentQueue
- 10 производителей, 10 потребителей, высокая конкуренция
Измерьте throughput и latency каждого варианта.

### Задача 3: Читатели-писатели с приоритетами
Три политики синхронизации:
1. Читатели в приоритете (писатели могут голодать)
2. Писатели в приоритете
3. Честная очередь (FIFO)

ReaderWriterLockSlim или собственная на SemaphoreSlim.
20 читателей, 5 писателей, 1M операций.
Сравните пропускную способность каждой политики.

---

## БИЛЕТ 24

### Задача 1: Асинхронный веб-краулер
Async краулер для скачивания страниц:
- HttpClient с async/await
- Параллельное скачивание (ограничение)
- Рекурсивный обход ссылок (глубина N)
- Respect robots.txt
- Rate limiting (X запросов/сек на домен)
- Retry для failed запросов
- CancellationToken для остановки

Скачайте 1000 страниц. Статистика: успешных, неудачных, скорость.

### Задача 2: Async-Await конвейер
Pipeline обработки данных:
Download -> Parse -> Transform -> Validate -> Save
Каждый этап async. Используйте Channel<T>.
- Отмена (CancellationToken)
- Progress reporting
- Error handling с retry
Обработайте 10000 элементов. Визуализируйте прогресс.

### Задача 3: Task координация и композиция
Сложные сценарии:
1. Task.WhenAll() - ждем всех
2. Task.WhenAny() - первый результат
3. Task с таймаутом (Task.Delay + cancellation)
4. ContinueWith() - последовательное выполнение
5. Retry с exponential backoff

Тестируйте все сценарии на 100+ задачах.

---

## БИЛЕТ 25

### Задача 1: Параллельный MapReduce
Фреймворк MapReduce локально на многоядерной машине:
- Map: распределить данные по чанкам, обработать параллельно
- Shuffle: сгруппировать по ключам
- Reduce: агрегировать результаты
- Используйте Parallel.ForEach и PLINQ

Задача: подсчет частоты слов в тексте 100MB+.
Сравните с последовательной обработкой. Ускорение?

### Задача 2: Параллельная сортировка слиянием
Parallel MergeSort через Task:
- Рекурсивно делить и сортировать параллельно
- Task.Run() для каждой части
- Threshold < 1000 элементов -> последовательная сортировка
- Измерьте speedup на 10^6, 10^7 элементов
Постройте график зависимости времени от параллелизма.

### Задача 3: Параллельная обработка с Dataflow
TPL Dataflow для ETL-процесса:
- TransformBlock для обработки
- BatchBlock для группировки
- ActionBlock для сохранения
- Настройка MaxDegreeOfParallelism
Обработайте 100000 записей. Приостановка/возобновление pipeline.

---

## БИЛЕТ 26

### Задача 1: Оптимальная структура для задачи
Задача: миллион записей, быстрый поиск, частые вставки, редкие удаления.
Реализуйте и сравните:
1. Dictionary<K, V>
2. SortedDictionary<K, V>
3. ConcurrentDictionary<K, V>
4. Пользовательская хеш-таблица
5. B-tree

Для каждой: вставка, поиск, удаление 10^6 операций.
Таблица сравнения, графики, выводы.

### Задача 2: LRU Cache с O(1)
Реализуйте LRU Cache используя Dictionary + doubly linked list:
- Get, Put за O(1)
- LRU eviction при переполнении
- Потокобезопасная версия (lock или ConcurrentDictionary)
- Статистика: hit rate, miss rate

10 потоков, 1M операций. Сравните synchronous vs lock-free версии.

### Задача 3: Graph структура с алгоритмами
Граф (adjacency list и matrix):
- DFS, BFS, Dijkstra (кратчайший путь)
- Prim/Kruskal (минимальное остовное дерево)
- Топологическая сортировка
- Компоненты связности

Тестируйте на разреженных и плотных графах из 10000 вершин.
Сравните performance adjacency list vs matrix.

---

## БИЛЕТ 27

### Задача 1: Профилировщик памяти
Инструмент анализа памяти:
- GC.GetTotalMemory(), GC.CollectionCount()
- Process.WorkingSet64
- Отслеживание выделений и освобождений
- Поиск memory leaks (объекты не освобождаются)
- Периодические снимки состояния heap

Графики потребления памяти по времени, распределение по поколениям.
Примените к приложению с утечками.

### Задача 2: Object Pool для дорогих объектов
ObjectPool<T> для переиспользования объектов (БД connections):
- Get() - взять из пула
- Return(obj) - вернуть в пул
- Min/max размер пула
- Validation объектов перед выдачей
- Lazy initialization
- Eviction неиспользуемых

Сравните: с пулом vs создание новых каждый раз.
1M операций, измерьте производительность.

### Задача 3: WeakReference коллекция
WeakCache<K, V> где значения могут быть собраны GC:
- Get(key) - вернуть или null
- GetOrAdd(key, factory)
- Значения в WeakReference<V>

Заполните кешем большие объекты, вызовите GC.Collect().
Проверьте что объекты были собраны. Демонстрируйте работу.

---

## БИЛЕТ 28

### Задача 1: Dependency Injection через рефлексию
Простой DI контейнер:
- Register<TInterface, TImplementation>()
- Resolve<T>() с автоматическим внедрением через конструктор
- Singleton, Transient, Scoped жизненные циклы
- Обнаружение циклических зависимостей
- Кеширование метаданных типов

10 классов с зависимостями. Тестируйте все жизненные циклы.

### Задача 2: Validator на атрибутах
Система валидации через атрибуты:
- [Required], [Range(min, max)], [StringLength(min, max)]
- [RegexPattern(pattern)], [Email], [CreditCard]
- [CustomValidation(methodName)]
- Validator<T> читает атрибуты через рефлексию
- Validate(obj) -> ValidationResult

Класс с 10+ свойствами. Кешируйте метаданные.

### Задача 3: Динамический Proxy для AOP
DispatchProxy или RealProxy для перехвата методов:
- Логирование (entry/exit, параметры, результаты)
- Измерение времени выполнения
- Кеширование результатов методов без параметров
- Обработка исключений
- Счетчики вызовов методов

Применить к интерфейсу с 5+ методами. Выведите статистику.

---

## БИЛЕТ 29

### Задача 1: Type-safe конфигурация с nullable
AppConfig с требуемыми и опциональными параметрами:
- Используйте required модификатор
- Nullable reference types для опциональных
- ConfigBuilder с fluent API и валидацией
- Build() бросает исключение если required не установлены
- Загрузка из JSON с обработкой missing полей

20+ параметров конфигурации. Тестируйте валидацию.

### Задача 2: Pattern Matching для State Machine
State Machine для заказов:
Состояния: Pending, Confirmed, Paid, Shipped, Delivered, Cancelled
События: Confirm, Pay, Ship, Deliver, Cancel

Используйте switch expression с pattern matching для переходов.
Условные переходы (зависит от свойств). Логирование переходов.
Обработайте 100 заказов через разные состояния.

### Задача 3: Дискриминируемые объединения (Discriminated Unions)
Result<T, E> (успех или ошибка):
- Success<T, E>(T Value)
- Failure<T, E>(E Error)

Методы: Match(onSuccess, onFailure), Map(func), Bind(func).
Pattern matching для разбора результата.
Цепочка операций которые могут завершиться ошибкой.

---

## БИЛЕТ 30

### Задача 1: Иммутабельная структура данных
Immutable binary search tree через records:
- Insert, Delete, Find -> новое дерево
- Structure sharing - копировать только измененный путь
- With-expression для модификации
- Сравните память с mutable версией
- Демонстрируйте персистентность (старые версии остаются)

1000 вставок, 1000 удалений. Анализ памяти.

### Задача 2: API клиент с современным C#
HTTP API клиент используя новые возможности C#:
- Records для DTO
- Init-only свойства
- Required модификатор
- Nullable reference types
- Pattern matching
- Global usings, file-scoped namespaces
- Raw string literals

CRUD операции, JSON сериализация, обработка ошибок, retry, cancellation.

### Задача 3: Domain Model с records
Domain model для системы бронирования:
- Customer, Hotel, Room, Booking, Payment records
- Positional records где уместно
- Value objects (Money, DateRange) как readonly record struct
- Validation в конструкторах
- 20+ бизнес-операций над моделью
- Immutability преимущества для domain logic

Симулируйте 50 бронирований с разными операциями.

---
