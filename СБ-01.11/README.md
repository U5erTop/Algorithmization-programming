## Раздел 1: Абстрактные классы 

1. Создайте абстрактный класс `Animal` с абстрактным методом `MakeSound()`.
2. Определите абстрактный класс `Shape` с абстрактным методом `CalculateArea()`.
3. Создайте абстрактный класс `Vehicle` и производные `Car` и `Motorcycle`.
4. Определите абстрактный метод `GetDescription()` в базовом классе.
5. Реализуйте абстрактный класс `Employee` с методом `CalculateSalary()`.
6. Создайте абстрактный класс `Database` с методами подключения.
7. Определите абстрактное свойство в абстрактном классе.
8. Реализуйте несколько производных классов от одного абстрактного.
9. Создайте абстрактный класс `Payment` с абстрактным методом `Process()`.
10. Определите абстрактный класс с конструктором.
11. Используйте абстрактный класс для создания иерархии фигур.
12. Создайте абстрактный класс `Logger` с различными реализациями логирования.
13. Определите абстрактный класс с несколькими абстрактными методами.
14. Реализуйте абстрактный класс для различных видов животных.
15. Создайте абстрактный класс `DataProcessor` для обработки данных.
16. Определите абстрактный класс `Authentication` для проверки прав доступа.
17. Реализуйте абстрактный класс `ReportGenerator` для генерации отчётов.
18. Создайте абстрактный класс `FileHandler` для работы с файлами.
19. Определите абстрактный класс `Validator` для валидации данных.
20. Реализуйте абстрактный класс `Notification` для отправки уведомлений.
21. Создайте абстрактный класс `Calculator` с абстрактными операциями.
22. Определите абстрактный класс `Connection` для работы с БД.
23. Реализуйте абстрактный класс `Cache` для кэширования.
24. Создайте абстрактный класс `Parser` для парсинга данных.
25. Определите абстрактный класс `Serializer` для сериализации.
26. Реализуйте абстрактный класс `Compressor` для сжатия.
27. Создайте абстрактный класс `Encryptor` для шифрования.
28. Определите абстрактный класс `Formatter` для форматирования.
29. Реализуйте абстрактный класс `Filter` для фильтрации данных.
30. Создайте абстрактный класс `Sorter` для сортировки.
31. Определите абстрактный класс `Builder` для построения объектов.
32. Реализуйте абстрактный класс `Strategy` для стратегий обработки.
33. Создайте абстрактный класс `Adapter` для адаптации интерфейсов.
34. Определите абстрактный класс `Observable` для наблюдателя.
35. Реализуйте абстрактный класс `Command` для команд.

## Раздел 2: Интерфейсы 

36. Создайте интерфейс `IAnimal` с методом `MakeSound()`.
37. Определите интерфейс `IShape` с методом `CalculateArea()`.
38. Реализуйте интерфейс `IComparable` для сравнения объектов.
39. Создайте интерфейс `IPayable` для оплаты.
40. Определите интерфейс `IDrawable` для рисования.
41. Реализуйте интерфейс `IEnumerable` для перечисления.
42. Создайте интерфейс `IDisposable` для освобождения ресурсов.
43. Определите интерфейс `ICloneable` для клонирования.
44. Реализуйте интерфейс `INotifyPropertyChanged` для уведомлений.
45. Создайте интерфейс `IRepository` для работы с хранилищем.
46. Определите интерфейс `ILogger` для логирования.
47. Реализуйте интерфейс `IValidator` для валидации.
48. Создайте интерфейс `IConverter` для конвертирования.
49. Определите интерфейс `IParser` для парсинга.
50. Реализуйте интерфейс `ISerializer` для сериализации.
51. Создайте интерфейс `IEncryptor` для шифрования.
52. Определите интерфейс `ICompressor` для сжатия.
53. Реализуйте интерфейс `IFilter` для фильтрации.
54. Создайте интерфейс `ISorter` для сортировки.
55. Определите интерфейс `IBuilder` для построения.
56. Реализуйте интерфейс `IStrategy` для стратегий.
57. Создайте интерфейс `IAdapter` для адаптации.
58. Определите интерфейс `IObserver` для наблюдения.
59. Реализуйте интерфейс `ICommand` для команд.
60. Создайте интерфейс `IFactory` для фабрики.
61. Определите интерфейс `IConnection` для подключения.
62. Реализуйте интерфейс `ICache` для кэширования.
63. Создайте интерфейс `IAuthentication` для аутентификации.
64. Определите интерфейс `IAuthorization` для авторизации.
65. Реализуйте несколько интерфейсов в одном классе.
66. Создайте интерфейс с методами и свойствами.
67. Определите интерфейс с неявной реализацией.
68. Реализуйте явную реализацию интерфейса.
69. Создайте интерфейс-наследник от другого интерфейса.
70. Определите интерфейс с дефолтными методами.

## Раздел 3: Паттерн Dependency Injection 

71. Создайте сервис с инъекцией зависимости через конструктор.
72. Определите интерфейс для логирования и внедрите зависимость.
73. Реализуйте класс с инъекцией нескольких зависимостей.
74. Создайте простой контейнер DI для регистрации сервисов.
75. Определите сервис с инъекцией через свойство.
76. Реализуйте фабрику для создания объектов с DI.
77. Создайте DI контейнер с поддержкой синглтонов.
78. Определите DI контейнер с поддержкой трансиентов.
79. Реализуйте DI контейнер с автоматической регистрацией типов.
80. Создайте сложную иерархию зависимостей с DI.
81. Определите DI контейнер для разрешения циклических зависимостей.
82. Реализуйте внедрение зависимости через метод.
83. Создайте сервис локатор для получения зависимостей.
84. Определите DI контейнер с параметризованными конструкторами.
85. Реализуйте DI контейнер с поддержкой обобщённых типов.
86. Создайте DI контейнер с декораторами.
87. Определите DI контейнер с интерцепторами.
88. Реализуйте DI контейнер с фабрикой для создания объектов.
89. Создайте DI контейнер с поддержкой стек трейсов ошибок.
90. Определите DI контейнер с профилированием.
91. Реализуйте многоуровневый DI контейнер.
92. Создайте DI контейнер для тестирования мокирование зависимостей.
93. Определите DI контейнер с поддержкой конфигурации.
94. Реализуйте DI контейнер с поддержкой плагинов.
95. Создайте DI контейнер с регистрацией через атрибуты.
96. Определите DI контейнер с поддержкой асинхронной инициализации.
97. Реализуйте DI контейнер с поддержкой сцепленных конструкторов.
98. Создайте DI контейнер для микросервисной архитектуры.
99. Определите DI контейнер с поддержкой миграции версий.
100. Реализуйте DI контейнер с резервным копированием состояния.

---

## Задача 1: Абстрактный класс Animal (Задача #1)

**Описание**: Создайте абстрактный класс `Animal` с абстрактным методом `MakeSound()`.

**Решение**:

```csharp
using System;

// Абстрактный базовый класс
abstract class Animal
{
    protected string name;

    public Animal(string name)
    {
        this.name = name;
    }

    // Абстрактный метод - должен быть переопределён в производном классе
    public abstract void MakeSound();

    // Конкретный метод в абстрактном классе
    public void Introduce()
    {
        Console.WriteLine($"Я {name}");
    }
}

// Конкретный класс - реализация абстрактного класса
class Dog : Animal
{
    public Dog(string name) : base(name)
    {
    }

    // Реализация абстрактного метода
    public override void MakeSound()
    {
        Console.WriteLine("Гав! Гав!");
    }
}

class Cat : Animal
{
    public Cat(string name) : base(name)
    {
    }

    public override void MakeSound()
    {
        Console.WriteLine("Мяу! Мяу!");
    }
}

class Program
{
    static void Main()
    {
        // Animal animal = new Animal("Животное"); // Ошибка! Нельзя создать объект абстрактного класса

        Dog dog = new Dog("Шарик");
        dog.Introduce();
        dog.MakeSound();

        Console.WriteLine();

        Cat cat = new Cat("Мурзик");
        cat.Introduce();
        cat.MakeSound();

        // Полиморфизм
        Console.WriteLine("\nПолиморфное поведение:");
        Animal[] animals = { dog, cat };
        foreach (Animal animal in animals)
        {
            animal.MakeSound();
        }
    }
}
```

**Вывод**:
```
Я Шарик
Гав! Гав!

Я Мурзик
Мяу! Мяу!

Полиморфное поведение:
Гав! Гав!
Мяу! Мяу!
```

**Объяснение**: Абстрактный класс нельзя инстанцировать напрямую. Он служит шаблоном для производных классов. Абстрактные методы должны быть реализованы в каждом производном классе. Это обеспечивает единый интерфейс для разных типов животных.

---

## Задача 2: Интерфейс IShape (Задача #36)

**Описание**: Создайте интерфейс `IShape` с методом `CalculateArea()`.

**Решение**:

```csharp
using System;

// Интерфейс определяет контракт
interface IShape
{
    double CalculateArea();
    string GetName();
}

// Реализация интерфейса для круга
class Circle : IShape
{
    private double radius;

    public Circle(double radius)
    {
        this.radius = radius;
    }

    public double CalculateArea()
    {
        return Math.PI * radius * radius;
    }

    public string GetName()
    {
        return "Круг";
    }
}

// Реализация интерфейса для прямоугольника
class Rectangle : IShape
{
    private double width;
    private double height;

    public Rectangle(double width, double height)
    {
        this.width = width;
        this.height = height;
    }

    public double CalculateArea()
    {
        return width * height;
    }

    public string GetName()
    {
        return "Прямоугольник";
    }
}

// Реализация интерфейса для треугольника
class Triangle : IShape
{
    private double a, b, c;

    public Triangle(double a, double b, double c)
    {
        this.a = a;
        this.b = b;
        this.c = c;
    }

    public double CalculateArea()
    {
        // Формула Герона
        double s = (a + b + c) / 2;
        return Math.Sqrt(s * (s - a) * (s - b) * (s - c));
    }

    public string GetName()
    {
        return "Треугольник";
    }
}

class Program
{
    static void Main()
    {
        // Создание объектов, реализующих интерфейс
        IShape circle = new Circle(5);
        IShape rectangle = new Rectangle(4, 6);
        IShape triangle = new Triangle(3, 4, 5);

        IShape[] shapes = { circle, rectangle, triangle };

        double totalArea = 0;

        foreach (IShape shape in shapes)
        {
            double area = shape.CalculateArea();
            Console.WriteLine($"{shape.GetName()}: Площадь = {area:F2}");
            totalArea += area;
        }

        Console.WriteLine($"\nОбщая площадь всех фигур: {totalArea:F2}");
    }
}
```

**Вывод**:
```
Круг: Площадь = 78.54
Прямоугольник: Площадь = 24.00
Треугольник: Площадь = 6.00

Общая площадь всех фигур: 108.54
```

**Объяснение**: Интерфейс определяет контракт — набор методов, которые должны быть реализованы. Разные классы могут реализовать один и тот же интерфейс по-разному. Это позволяет работать с объектами разных типов через единый интерфейс.

---

## Задача 3: Dependency Injection через конструктор (Задача #71)

**Описание**: Создайте сервис с инъекцией зависимости через конструктор.

**Решение**:

```csharp
using System;

// Интерфейс логирования
interface ILogger
{
    void Log(string message);
}

// Реализация логирования в консоль
class ConsoleLogger : ILogger
{
    public void Log(string message)
    {
        Console.WriteLine($"[ЛОГА] {DateTime.Now:HH:mm:ss} - {message}");
    }
}

// Реализация логирования в файл
class FileLogger : ILogger
{
    public void Log(string message)
    {
        Console.WriteLine($"[ФАЙЛ] {DateTime.Now:HH:mm:ss} - {message}");
        // В реальном коде здесь была бы запись в файл
    }
}

// Сервис заказов - зависит от логирования
class OrderService
{
    private readonly ILogger logger;

    // Инъекция зависимости через конструктор
    public OrderService(ILogger logger)
    {
        this.logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public void CreateOrder(string orderId)
    {
        logger.Log($"Начало создания заказа: {orderId}");
        // Логика создания заказа
        logger.Log($"Заказ {orderId} успешно создан");
    }

    public void CancelOrder(string orderId)
    {
        logger.Log($"Отмена заказа: {orderId}");
        // Логика отмены
        logger.Log($"Заказ {orderId} успешно отменён");
    }
}

// Сервис платежей - также зависит от логирования
class PaymentService
{
    private readonly ILogger logger;

    public PaymentService(ILogger logger)
    {
        this.logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public void ProcessPayment(string paymentId, decimal amount)
    {
        logger.Log($"Обработка платежа {paymentId} на сумму {amount}");
        // Логика обработки платежа
        logger.Log($"Платёж {paymentId} успешно обработан");
    }
}

class Program
{
    static void Main()
    {
        // Создание логирования
        ILogger logger = new ConsoleLogger();

        // Инъекция одной и той же зависимости в разные сервисы
        var orderService = new OrderService(logger);
        var paymentService = new PaymentService(logger);

        // Использование сервисов
        orderService.CreateOrder("ORD-001");
        paymentService.ProcessPayment("PAY-001", 99.99m);
        orderService.CancelOrder("ORD-001");

        Console.WriteLine("\n--- Переключение на логирование в файл ---\n");

        // Смена реализации логирования без изменения сервисов!
        ILogger fileLogger = new FileLogger();
        var newOrderService = new OrderService(fileLogger);

        newOrderService.CreateOrder("ORD-002");
        newOrderService.CancelOrder("ORD-002");
    }
}
```

**Вывод**:
```
[ЛОГА] 19:45:23 - Начало создания заказа: ORD-001
[ЛОГА] 19:45:23 - Заказ ORD-001 успешно создан
[ЛОГА] 19:45:23 - Обработка платежа PAY-001 на сумму 99,99
[ЛОГА] 19:45:23 - Платёж PAY-001 успешно обработан
[ЛОГА] 19:45:23 - Отмена заказа: ORD-001
[ЛОГА] 19:45:23 - Заказ ORD-001 успешно отменён

--- Переключение на логирование в файл ---

[ФАЙЛ] 19:45:23 - Начало создания заказа: ORD-002
[ФАЙЛ] 19:45:23 - Заказ ORD-002 успешно создан
[ФАЙЛ] 19:45:23 - Отмена заказа: ORD-002
[ФАЙЛ] 19:45:23 - Заказ ORD-002 успешно отменён
```

**Объяснение**: Dependency Injection (внедрение зависимостей) — это паттерн, при котором объект получает свои зависимости извне, а не создаёт их сам. Преимущества:
- Легче тестировать (можно подставить mock объект)
- Легче менять реализацию без изменения кода сервиса
- Меньше связанности между классами
- Более гибкий и масштабируемый код

---

## Задача 4: Простой DI контейнер (Задача #72)

**Описание**: Создайте простой контейнер для управления зависимостями.

**Решение**:

```csharp
using System;
using System.Collections.Generic;

// Интерфейсы сервисов
interface IRepository
{
    void Save(string data);
}

interface ILogger
{
    void Log(string message);
}

interface IEmailService
{
    void SendEmail(string to, string subject);
}

// Реализации
class Database : IRepository
{
    public void Save(string data)
    {
        Console.WriteLine($"Сохранение в БД: {data}");
    }
}

class ConsoleLogger : ILogger
{
    public void Log(string message)
    {
        Console.WriteLine($"[LOG] {message}");
    }
}

class EmailService : IEmailService
{
    private readonly ILogger logger;

    public EmailService(ILogger logger)
    {
        this.logger = logger;
    }

    public void SendEmail(string to, string subject)
    {
        logger.Log($"Отправка email на {to}: {subject}");
        Console.WriteLine("Email отправлен");
    }
}

// Простой DI контейнер
class DIContainer
{
    private Dictionary<Type, Type> registrations = new Dictionary<Type, Type>();
    private Dictionary<Type, object> singletons = new Dictionary<Type, object>();

    // Регистрация типов
    public void Register<TInterface, TImplementation>(bool singleton = false)
        where TImplementation : TInterface
    {
        Type interfaceType = typeof(TInterface);
        Type implementationType = typeof(TImplementation);

        registrations[interfaceType] = implementationType;

        if (singleton)
        {
            var instance = Activator.CreateInstance(implementationType);
            singletons[interfaceType] = instance;
        }
    }

    // Получение экземпляра
    public T Resolve<T>()
    {
        return (T)Resolve(typeof(T));
    }

    private object Resolve(Type type)
    {
        // Проверка синглтонов
        if (singletons.ContainsKey(type))
        {
            return singletons[type];
        }

        if (!registrations.ContainsKey(type))
        {
            throw new Exception($"Тип {type.Name} не зарегистрирован");
        }

        Type implementationType = registrations[type];
        var constructors = implementationType.GetConstructors();

        if (constructors.Length == 0)
        {
            return Activator.CreateInstance(implementationType);
        }

        var constructor = constructors[0];
        var parameters = constructor.GetParameters();

        var parameterInstances = new object[parameters.Length];
        for (int i = 0; i < parameters.Length; i++)
        {
            parameterInstances[i] = Resolve(parameters[i].ParameterType);
        }

        return Activator.CreateInstance(implementationType, parameterInstances);
    }
}

class Program
{
    static void Main()
    {
        // Создание и настройка контейнера
        var container = new DIContainer();

        // Регистрация типов
        container.Register<ILogger, ConsoleLogger>(singleton: true);
        container.Register<IRepository, Database>();
        container.Register<IEmailService, EmailService>();

        // Получение сервисов из контейнера
        var emailService = container.Resolve<IEmailService>();

        // Использование
        emailService.SendEmail("user@example.com", "Добро пожаловать!");

        Console.WriteLine();

        var logger = container.Resolve<ILogger>();
        logger.Log("Это сообщение от системы");

        var repository = container.Resolve<IRepository>();
        repository.Save("Важные данные");
    }
}
```

**Вывод**:
```
[LOG] Отправка email на user@example.com: Добро пожаловать!
Email отправлен

[LOG] Это сообщение от системы
Сохранение в БД: Важные данные
```

**Объяснение**: DIContainer — это контейнер, который управляет созданием объектов и внедрением зависимостей. Он позволяет:
- Регистрировать типы и их реализации
- Автоматически разрешать зависимости
- Управлять синглтонами (один экземпляр на всё приложение)
- Упростить инициализацию сложных объектов

---

## Задача 5: Множественная реализация интерфейсов (Задача #65)

**Описание**: Реализуйте несколько интерфейсов в одном классе.

**Решение**:

```csharp
using System;

// Несколько интерфейсов
interface INameable
{
    string GetName();
}

interface IDescribable
{
    string GetDescription();
}

interface IComparable
{
    bool IsEqualTo(object obj);
}

interface IPrintable
{
    void Print();
}

// Класс, реализующий несколько интерфейсов
class Document : INameable, IDescribable, IComparable, IPrintable
{
    private string name;
    private string content;
    private DateTime createdDate;

    public Document(string name, string content)
    {
        this.name = name;
        this.content = content;
        this.createdDate = DateTime.Now;
    }

    // Реализация INameable
    public string GetName()
    {
        return name;
    }

    // Реализация IDescribable
    public string GetDescription()
    {
        return $"Документ '{name}' создан {createdDate:dd.MM.yyyy HH:mm}. " +
               $"Размер: {content.Length} символов";
    }

    // Реализация IComparable
    public bool IsEqualTo(object obj)
    {
        if (obj is Document other)
        {
            return this.name == other.name && this.content == other.content;
        }
        return false;
    }

    // Реализация IPrintable
    public void Print()
    {
        Console.WriteLine("═════════════════════════════");
        Console.WriteLine($"Название: {GetName()}");
        Console.WriteLine("─────────────────────────────");
        Console.WriteLine($"Содержание: {content}");
        Console.WriteLine($"Создан: {createdDate:dd.MM.yyyy HH:mm:ss}");
        Console.WriteLine("═════════════════════════════");
    }
}

class Program
{
    static void Main()
    {
        // Создание документов
        var doc1 = new Document("Отчёт", "Это годовой отчёт по доходам");
        var doc2 = new Document("Письмо", "Это официальное письмо");
        var doc3 = new Document("Отчёт", "Это годовой отчёт по доходам");

        // Использование интерфейса INameable
        Console.WriteLine($"Имя документа: {doc1.GetName()}");
        Console.WriteLine();

        // Использование интерфейса IDescribable
        Console.WriteLine($"Описание: {doc1.GetDescription()}");
        Console.WriteLine();

        // Использование интерфейса IComparable
        Console.WriteLine($"doc1 равен doc2? {doc1.IsEqualTo(doc2)}");
        Console.WriteLine($"doc1 равен doc3? {doc1.IsEqualTo(doc3)}");
        Console.WriteLine();

        // Использование интерфейса IPrintable
        doc1.Print();
        doc2.Print();

        // Работа через интерфейсы
        Console.WriteLine("\nПолиморфная работа с интерфейсами:");
        INameable nameable = doc1;
        IDescribable describable = doc2;
        IPrintable printable = doc3;

        Console.WriteLine($"Документ: {nameable.GetName()}");
        Console.WriteLine($"Описание: {describable.GetDescription()}");
        printable.Print();
    }
}
```

**Вывод**:
```
Имя документа: Отчёт

Описание: Документ 'Отчёт' создан 31.10.2025 18:30. Размер: 31 символов

doc1 равен doc2? False
doc1 равен doc3? True

═════════════════════════════
Название: Отчёт
─────────────────────────────
Содержание: Это годовой отчёт по доходам
Создан: 31.10.2025 18:30:45
═════════════════════════════
═════════════════════════════
Название: Письмо
─────────────────────────────
Содержание: Это официальное письмо
Создан: 31.10.2025 18:30:45
═════════════════════════════

Полиморфная работа с интерфейсами:
Документ: Отчёт
Описание: Документ 'Письмо' создан 31.10.2025 18:30. Размер: 25 символов
═════════════════════════════
Название: Отчёт
─────────────────────────────
Содержание: Это годовой отчёт по доходам
Создан: 31.10.2025 18:30:45
═════════════════════════════
```

**Объяснение**: Класс может реализовать несколько интерфейсов одновременно. Это позволяет объекту поддерживать различные контракты и использоваться в разных контекстах. Каждый интерфейс определяет набор методов, которые класс должен реализовать.

---

## Краткое Резюме

| Концепция | Назначение | Пример |
|-----------|-----------|--------|
| **Абстрактный класс** | Определяет общий интерфейс для наследников | `abstract class Animal` |
| **Абстрактный метод** | Должен быть реализован в производных классах | `abstract void MakeSound();` |
| **Интерфейс** | Определяет контракт для реализации | `interface IShape` |
| **Реализация интерфейса** | Класс выполняет все методы интерфейса | `class Circle : IShape` |
| **Dependency Injection** | Внедрение зависимостей через конструктор | `new OrderService(logger)` |
| **DI Container** | Автоматическое управление зависимостями | `container.Resolve<T>()` |
| **Синглтон** | Один экземпляр на приложение | `singleton: true` |
