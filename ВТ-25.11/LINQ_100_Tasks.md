# C# LINQ

## Краткое описание LINQ

**LINQ (Language Integrated Query)** — это интегрированный язык запросов в C#, который позволяет выполнять операции фильтрации, трансформации, сортировки и агрегации данных с помощью синтаксиса, похожего на SQL. LINQ работает с любыми источниками данных: массивы, коллекции, базы данных, XML-документы.

### Основные преимущества:
- **Единообразный синтаксис** для работы с разными источниками данных
- **Читаемость кода** благодаря декларативному стилю вместо циклов
- **Типобезопасность** на этапе компиляции
- **IntelliSense поддержка** в IDE
- **Оптимизация** за счет отложенного выполнения (lazy evaluation)

### Основные операторы LINQ:
- **Where** — фильтрация элементов
- **Select** — преобразование/проекция элементов
- **OrderBy/OrderByDescending** — сортировка
- **GroupBy** — группировка данных
- **Join** — соединение коллекций
- **Aggregate** — операции агрегации (Sum, Count, Average, Max, Min)
- **Distinct** — удаление дубликатов
- **Take/Skip** — выборка элементов
- **First/Last** — получение первого/последнего элемента
- **SelectMany** — разворачивание вложенных коллекций
- **Any/All** — проверка условий
- **Concat** — объединение коллекций

---

### Категория 1: Where (Фильтрация)

**Задание 1 (Beginner):** Создайте запрос LINQ, который выбирает все числа больше 50 из массива [10, 25, 50, 75, 100, 150]

**Задание 2 (Beginner):** Напишите LINQ запрос для фильтрации четных чисел из списка [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

**Задание 3 (Beginner):** Отберите из списка строк только те, которые начинаются с буквы 'A': ["Apple", "Banana", "Apricot", "Orange", "Avocado"]

**Задание 4 (Intermediate):** Фильтруйте список объектов Person с свойствами (Name, Age) и выберите всех, кто старше 30 лет

**Задание 5 (Beginner):** Выберите все числа из массива, которые делятся на 3 нацело

**Задание 6 (Intermediate):** Фильтруйте список студентов и верните только тех, чей средний балл выше 4.0

**Задание 7 (Beginner):** Выберите строки длиной более 5 символов из списка: ["Hi", "Hello", "World", "Programming"]

**Задание 8 (Intermediate):** Отберите товары из каталога с ценой между 100 и 500 рублей

**Задание 9 (Beginner):** Выберите только положительные числа из смешанного списка

**Задание 10 (Intermediate):** Фильтруйте сотрудников с зарплатой выше среднего и стажем более 2 лет

### Категория 2: Select (Проекция)

**Задание 11 (Beginner):** Преобразуйте список чисел в их квадраты: [1, 2, 3, 4, 5]

**Задание 12 (Beginner):** Извлеките только имена из списка объектов Person

**Задание 13 (Intermediate):** Создайте новый список, содержащий информацию в формате "Name - Age" из данных Person

**Задание 14 (Beginner):** Преобразуйте список строк в их длины

**Задание 15 (Intermediate):** Создайте список объектов с выбранными свойствами из исходного объекта

**Задание 16 (Beginner):** Преобразуйте цены в доллары, зная что 1 доллар = 100 рублей

**Задание 17 (Intermediate):** Создайте анонимные типы с выбранными свойствами (ProjectionQuery)

**Задание 18 (Beginner):** Преобразуйте список в список с добавленным префиксом к каждой строке

**Задание 19 (Intermediate):** Извлеките email-адреса и форматируйте их в специальный вид

**Задание 20 (Beginner):** Преобразуйте список объектов в список кортежей (Tuple)

### Категория 3: OrderBy/ThenBy (Сортировка)

**Задание 21 (Beginner):** Отсортируйте массив чисел [5, 2, 8, 1, 9] в порядке возрастания

**Задание 22 (Beginner):** Отсортируйте список имен в обратном порядке (Z-A)

**Задание 23 (Intermediate):** Отсортируйте список Person сначала по возрасту, затем по имени

**Задание 24 (Beginner):** Отсортируйте строки по их длине (от коротких к длинным)

**Задание 25 (Intermediate):** Отсортируйте товары по цене в порядке убывания

**Задание 26 (Intermediate):** Отсортируйте студентов по баллам (по убыванию), а при равных баллах по фамилии

**Задание 27 (Beginner):** Отсортируйте числа по количеству делителей

**Задание 28 (Intermediate):** Отсортируйте сотрудников сначала по отделу, потом по зарплате

**Задание 29 (Beginner):** Отсортируйте даты в хронологическом порядке

**Задание 30 (Intermediate):** Отсортируйте продукты по категории, затем по популярности

### Категория 4: GroupBy (Группировка)

**Задание 31 (Intermediate):** Сгруппируйте числа [1,2,3,4,5,6,7,8,9,10] по четности (четные/нечетные)

**Задание 32 (Intermediate):** Сгруппируйте список Person по возрасту

**Задание 33 (Intermediate):** Сгруппируйте товары по категориям и покажите количество товаров в каждой

**Задание 34 (Advanced):** Сгруппируйте студентов по факультету и найдите средний балл в каждой группе

**Задание 35 (Intermediate):** Сгруппируйте сотрудников по отделу и выведите сумму зарплат по отделам

**Задание 36 (Advanced):** Сгруппируйте заказы по клиентам и найдите самый дорогой заказ для каждого

**Задание 37 (Intermediate):** Сгруппируйте строки по первой букве

**Задание 38 (Advanced):** Сгруппируйте события по датам и подсчитайте количество событий в каждый день

**Задание 39 (Intermediate):** Сгруппируйте продажи по месяцам и найдите итоговую сумму

**Задание 40 (Advanced):** Сгруппируйте данные двухуровневой группировкой (категория -> подкатегория)

### Категория 5: Join (Объединение)

**Задание 41 (Intermediate):** Объедините список студентов со списком их оценок по ID студента

**Задание 42 (Intermediate):** Сделайте внутреннее соединение (Inner Join) таблиц Employees и Departments

**Задание 43 (Advanced):** Выполните левое соединение (Left Join) для получения всех клиентов и их заказов

**Задание 44 (Intermediate):** Объедините список товаров с их производителями по ID

**Задание 45 (Advanced):** Выполните объединение с использованием составного ключа (несколько полей)

**Задание 46 (Intermediate):** Соедините три таблицы: Customers, Orders, Products

**Задание 47 (Advanced):** Выполните группировано объединение (GroupJoin)

**Задание 48 (Intermediate):** Создайте кросс-соединение двух коллекций

**Задание 49 (Advanced):** Выполните объединение с фильтрацией условий перед соединением

**Задание 50 (Intermediate):** Объедините данные из двух источников с разными структурами

### Категория 6: Aggregate Functions (Агрегирование)

**Задание 51 (Beginner):** Найдите сумму всех чисел в списке [1, 2, 3, 4, 5]

**Задание 52 (Beginner):** Найдите среднее значение набора чисел

**Задание 53 (Beginner):** Найдите максимум и минимум из списка

**Задание 54 (Intermediate):** Подсчитайте количество элементов, удовлетворяющих условию

**Задание 55 (Intermediate):** Вычислите произведение всех чисел в списке

**Задание 56 (Intermediate):** Найдите медиану списка чисел

**Задание 57 (Beginner):** Проверьте, содержит ли список хотя бы одно число больше 100

**Задание 58 (Advanced):** Используйте метод Aggregate для вычисления факториала

**Задание 59 (Intermediate):** Найдите сумму квадратов всех нечетных чисел

**Задание 60 (Intermediate):** Вычислите стандартное отклонение набора значений

### Категория 7: Set Operations (Операции над множествами)

**Задание 61 (Beginner):** Удалите дубликаты из списка [1, 2, 2, 3, 3, 3, 4]

**Задание 62 (Intermediate):** Найдите объединение двух списков [1,2,3] и [3,4,5]

**Задание 63 (Intermediate):** Найдите разницу между двумя списками (элементы в первом, но не во втором)

**Задание 64 (Intermediate):** Найдите пересечение двух списков [1,2,3,4] и [3,4,5,6]

**Задание 65 (Intermediate):** Удалите дубликаты строк с учетом регистра

**Задание 66 (Advanced):** Используйте Distinct с пользовательским компаратором

**Задание 67 (Intermediate):** Найдите элементы, которые есть в обоих списках

**Задание 68 (Advanced):** Выполните симметрическую разность двух списков

### Категория 8: Partitioning (Партиционирование)

**Задание 69 (Beginner):** Возьмите первые 3 элемента из списка [1,2,3,4,5]

**Задание 70 (Beginner):** Пропустите первые 2 элемента и возьмите остальное

**Задание 71 (Beginner):** Найдите первый элемент, удовлетворяющий условию

**Задание 72 (Beginner):** Найдите последний элемент списка

**Задание 73 (Intermediate):** Реализуйте пагинацию: пропустите N элементов и возьмите M

**Задание 74 (Intermediate):** Возьмите элементы, пока выполняется условие (TakeWhile)

**Задание 75 (Intermediate):** Пропустите элементы, пока выполняется условие (SkipWhile)

**Задание 76 (Beginner):** Возьмите последние 3 элемента из списка

### Категория 9: SelectMany (Разворачивание)

**Задание 77 (Intermediate):** Разверните список списков в один список

**Задание 78 (Intermediate):** Создайте декартово произведение двух коллекций

**Задание 79 (Advanced):** Преобразуйте иерархическую структуру в плоский список

**Задание 80 (Intermediate):** Используйте SelectMany для получения всех элементов из вложенных коллекций

**Задание 81 (Advanced):** Создайте список всех комбинаций элементов из нескольких коллекций

**Задание 82 (Intermediate):** Преобразуйте список строк, где каждая строка расчленяется на символы

**Задание 83 (Advanced):** Используйте SelectMany с индексом для сохранения информации о позиции

**Задание 84 (Intermediate):** Объедините несколько коллекций в одну с использованием SelectMany

### Категория 10: Quantifiers (Проверка условий)

**Задание 85 (Beginner):** Проверьте, содержит ли список хотя бы одно число больше 10

**Задание 86 (Intermediate):** Проверьте, все ли элементы списка больше нуля

**Задание 87 (Beginner):** Проверьте, содержит ли список конкретное значение

**Задание 88 (Intermediate):** Проверьте, содержит ли список объект с определенными свойствами

**Задание 89 (Beginner):** Определите, является ли список пустым

**Задание 90 (Intermediate):** Проверьте, содержит ли коллекция ровно N элементов

### Категория 11: Concatenation (Объединение)

**Задание 91 (Beginner):** Объедините два массива [1,2,3] и [4,5,6]

**Задание 92 (Beginner):** Объедините несколько списков строк в один

**Задание 93 (Intermediate):** Объедините коллекции с различными типами элементов (с приведением типов)

**Задание 94 (Intermediate):** Объедините отсортированные списки, сохраняя сортировку

### Категория 12: Casting (Приведение типов)

**Задание 95 (Intermediate):** Приведите список объектов типа object к типу int

**Задание 96 (Intermediate):** Отберите только элементы определенного типа из смешанного списка

**Задание 97 (Advanced):** Используйте OfType для фильтрации элементов нужного типа из неоднородной коллекции

**Задание 98 (Intermediate):** Преобразуйте список значений в список другого типа безопасно

### Категория 13: Complex Queries (Сложные запросы)

**Задание 99 (Advanced):** Создайте сложный запрос: группировка -> фильтрация -> сортировка с вычисленными полями

**Задание 100 (Advanced):** Выполните многоэтапный запрос: соединение -> группировка -> агрегация -> сортировка

---

## РЕШЕНИЯ 5 СЛУЧАЙНО ВЫБРАННЫХ ЗАДАНИЙ

### ✅ Решение Задания #27: OrderBy (Beginner)
**Текст:** Отсортируйте числа по количеству делителей

```csharp
int[] numbers = { 12, 5, 24, 7, 18, 9, 11 };

// Функция для подсчета делителей
int CountDivisors(int n)
{
    int count = 0;
    for (int i = 1; i <= n; i++)
        if (n % i == 0) count++;
    return count;
}

// LINQ запрос
var sortedByDivisors = numbers
    .OrderBy(n => CountDivisors(n))
    .ThenBy(n => n)
    .ToList();

Console.WriteLine(string.Join(", ", sortedByDivisors));
// Вывод: 5, 7, 11, 9, 18, 12, 24
// Объяснение: 5,7,11 имеют по 2 делителя; 9,18 имеют по 3; 12,24 имеют по 6
```

**Описание:** Используем `OrderBy()` с функцией `CountDivisors()` для сортировки чисел по возрастанию количества делителей. При равном количестве делителей сортируем по самому числу с помощью `ThenBy()`.

---

### ✅ Решение Задания #64: SetOperations (Intermediate)
**Текст:** Найдите пересечение двух списков [1,2,3,4] и [3,4,5,6]

```csharp
List<int> list1 = new List<int> { 1, 2, 3, 4 };
List<int> list2 = new List<int> { 3, 4, 5, 6 };

// Способ 1: Использование Intersect()
var intersection = list1.Intersect(list2).ToList();
Console.WriteLine($"Пересечение: {string.Join(", ", intersection)}");
// Вывод: 3, 4

// Способ 2: Использование Where() с Contains()
var intersection2 = list1.Where(x => list2.Contains(x)).ToList();
Console.WriteLine($"Альтернативный способ: {string.Join(", ", intersection2)}");
// Вывод: 3, 4

// Способ 3: С сохранением уникальности
var intersection3 = list1.Intersect(list2).Distinct().OrderBy(x => x).ToList();
Console.WriteLine($"С сортировкой: {string.Join(", ", intersection3)}");
// Вывод: 3, 4
```

**Описание:** Метод `Intersect()` возвращает элементы, присутствующие в обеих коллекциях. Это операция пересечения множеств. Результат содержит только уникальные элементы.

---

### ✅ Решение Задания #75: Partitioning (Intermediate)
**Текст:** Пропустите элементы, пока выполняется условие (SkipWhile)

```csharp
int[] numbers = { 1, 2, 3, 5, 4, 6, 2, 7, 8 };

// Пропустить числа, пока они меньше 5
var result = numbers.SkipWhile(x => x < 5).ToList();
Console.WriteLine($"После SkipWhile: {string.Join(", ", result)}");
// Вывод: 5, 4, 6, 2, 7, 8

// С индексом: пропустить первые 3 нечетных числа
var result2 = numbers.SkipWhile((x, index) => x % 2 != 0 && index < 3).ToList();
Console.WriteLine($"С индексом: {string.Join(", ", result2)}");
// Вывод: 5, 4, 6, 2, 7, 8

// Практический пример: пропустить записи логов начального уровня
List<string> logs = new List<string>
{
    "INFO: Приложение запущено",
    "DEBUG: Загрузка конфигурации",
    "DEBUG: Инициализация",
    "ERROR: Ошибка подключения",
    "ERROR: Повторная попытка"
};

var errorLogs = logs.SkipWhile(log => !log.Contains("ERROR")).ToList();
foreach (var log in errorLogs)
    Console.WriteLine(log);
// Выведет только записи с ERROR и после
```

**Описание:** `SkipWhile()` пропускает элементы последовательности, пока выполняется условие, и возвращает остаток. Метод останавливается при первом элементе, не удовлетворяющем условию. Есть также вариант с индексом.

---

### ✅ Решение Задания #89: Quantifier (Beginner)
**Текст:** Определите, является ли список пустым

```csharp
// Способ 1: Использование Any()
List<int> emptyList = new List<int>();
bool isEmpty1 = !emptyList.Any();
Console.WriteLine($"Список пуст (Any): {isEmpty1}"); // True

// Способ 2: Проверка Count()
bool isEmpty2 = emptyList.Count() == 0;
Console.WriteLine($"Список пуст (Count): {isEmpty2}"); // True

// Способ 3: Проверка свойства Count (для List)
bool isEmpty3 = emptyList.Count == 0;
Console.WriteLine($"Список пуст (Count property): {isEmpty3}"); // True

// Способ 4: Проверка через LongCount()
bool isEmpty4 = emptyList.LongCount() == 0;
Console.WriteLine($"Список пуст (LongCount): {isEmpty4}"); // True

// Практический пример
List<string> names = new List<string>();

if (!names.Any())
    Console.WriteLine("Список имен пуст, добавьте новые имена");
else
    Console.WriteLine($"В списке {names.Count()} имен");

// С условием
var adults = names.Where(n => n.Length > 5);
if (!adults.Any())
    Console.WriteLine("Нет имен с длиной > 5 символов");

// Рекомендация: Any() - самый быстрый способ
// Он не перебирает весь список, а останавливается при первом элементе
```

**Описание:** Лучший способ проверить, пуст ли список в LINQ — это использовать метод `Any()` с отрицанием. Это эффективнее, чем `Count() == 0`, потому что `Any()` останавливается при первом найденном элементе и не перебирает весь список.

---

### ✅ Решение Задания #97: Casting (Advanced)
**Текст:** Используйте OfType для фильтрации элементов нужного типа из неоднородной коллекции

```csharp
// Создание смешанной коллекции
object[] mixedData = { 1, "Hello", 2, "World", 3.14, 4, true, "Test", 5 };

// Способ 1: OfType<T>() для фильтрации целых чисел
var integers = mixedData.OfType<int>().ToList();
Console.WriteLine($"Целые числа: {string.Join(", ", integers)}");
// Вывод: 1, 2, 4, 5

// Способ 2: OfType<T>() для фильтрации строк
var strings = mixedData.OfType<string>().ToList();
Console.WriteLine($"Строки: {string.Join(", ", strings)}");
// Вывод: Hello, World, Test

// Способ 3: OfType для других типов
var doubles = mixedData.OfType<double>().ToList();
var bools = mixedData.OfType<bool>().ToList();
Console.WriteLine($"Число типа double: {doubles.Count}"); // 1
Console.WriteLine($"Булевы значения: {bools.Count}"); // 1

// Практический пример: Работа с наследованием
abstract class Animal { public string Name { get; set; } }
class Dog : Animal { }
class Cat : Animal { }
class Bird : Animal { }

List<Animal> animals = new List<Animal>
{
    new Dog { Name = "Rex" },
    new Cat { Name = "Whiskers" },
    new Bird { Name = "Tweety" },
    new Dog { Name = "Buddy" },
    new Cat { Name = "Mittens" }
};

// Получить только собак
var dogs = animals.OfType<Dog>().ToList();
Console.WriteLine($"Собаки: {string.Join(", ", dogs.Select(d => d.Name))}");
// Вывод: Rex, Buddy

// Получить только кошек
var cats = animals.OfType<Cat>().ToList();
Console.WriteLine($"Кошки: {string.Join(", ", cats.Select(c => c.Name))}");
// Вывод: Whiskers, Mittens

// Сравнение с Cast() - Cast требует, чтобы ВСЕ элементы были нужного типа
try
{
    var badCast = mixedData.Cast<int>().ToList(); // Выбросит исключение!
}
catch (InvalidCastException)
{
    Console.WriteLine("Cast выбросил исключение, потому что не все элементы - int");
}

// OfType - безопасен, просто пропускает неподходящие типы
var safeCast = mixedData.OfType<int>().ToList(); // Работает без ошибок
Console.WriteLine($"OfType безопасен: {safeCast.Count} целых чисел найдено");
```

**Описание:** `OfType<T>()` — это безопасный метод фильтрации, который возвращает только элементы указанного типа из неоднородной коллекции. Отличие от `Cast<T>()` в том, что `OfType` не выбрасывает исключение при несовместимом типе, а просто пропускает такие элементы. Это полезно при работе с:
- Смешанными типами данных
- Иерархией классов с полиморфизмом
- API, которые работают с `object[]` или `IEnumerable`

---

## РЕКОМЕНДАЦИИ ДЛЯ ПРАКТИКИ

1. **Для начинающих:** Начните с заданий категорий Where и Select (задания 1-20)
2. **Для продвинутых:** Практикуйтесь на сложных запросах (задания 99-100) и комбинированиях операторов
3. **Для оптимизации:** Помните про отложенное выполнение (lazy evaluation) и материализацию данных (.ToList())
4. **Лучшие практики:**
   - Используйте `Any()` вместо `Count() > 0` для проверки существования
   - Применяйте `OfType<T>()` для безопасного приведения типов
   - Кэшируйте результаты запросов, если они используются несколько раз
   - Используйте `IEnumerable` вместо материализации, когда возможно
